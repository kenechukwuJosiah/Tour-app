#Apis and Restful Api Design
Rest Api is an api architecture which is the most used.
Api stand for Application Programming Interface. Which is a piece of software that can be used by another piece of software in order to allow applicaitons to talk to each other like exchanging datas. 

REST stand for representational State Transfer. Which is a way of building api in lgical way making them easy to consume for ourselves or others to consume. Rest api are apis following the rest architecture.

Steps for building restful Apis
-Separate API into logical resources
-Expose structured resource-based urls
-Use HTTP methods in exposing them not urls
-send data as JSON
-it must be stateless.

#Separating api into logical resources
The resources here is an object or representation of something, which has data associated to it i.e any information that can be named can be a resource.

#Exposing structured resource-based urls which is url e.g https://www.natours.com/addNewTour the addNewTour is an endpoint The end points performs differnt action when a request hits them.

Note: put and patch http method are similar but the put is used to update a whole resource while that of patch is used to update only the part of the resource that is changed.

The four http method that should be responded to while building a restful api are post, get, put, patch, delete.

JSON: is light weight data interchange format which is heavly used by web api or sending data btw server and the clients.

#Statless Restful api: All state is handled on the client. A state is simply a piece of data that will change over time. So if all state will be handled in the client each request should contain everything needed to proccess the page

Note: the url parameter can be accessed from req.params. The parameter is a varrible that takes the value entered in the url. req.params is an object that hold all the params.

//////////////////////////////////////////////
//MidleWare, MidleWare and reqponse request cycle
They are function that are being executed btw the req and res cycle. the req and res object pass through this middleware i.e you can access the req in any MidleWare handler. 
There can be more than one middleware in our middleware stack. use the use() method to create a middleware in your app. After each middleware its adviceable to use the next() method in other for the proccess to continue. violation of this convention will leave the proccess stuck and that will be a very bad user experience for the user. if the MidleWare comes after the request handler the middleware won't work on that request cycle because by sending back data with the .json() method or .send() method the request resoponse method. 

#Param middleware: this is a special type of middleware function that only run for certain parameter i.e url parameter. the middleware function takes four parameters which are the req object, res object, next() method and the param value

Note: 400 status code stands for bad request or invalid request.

////////////////////////////////////
//Varriable Environment

////////////////////////////////////
//Mongo db
To create a local db using mongo db enter mongo in your command line to open mongo shell then enter use plus the name of the database to create a database. This use command will switch you to already existing db if the name you entered matches it. Inside a db we have collections and each collections has documents i.e (the data we create) in it.

e.g db.tours.insertOne(Dataobject);
The db is the current database, tours is the collection and the insertOne is for inserting only one data while insertMany is for more than one data.

some basic commands in mongodb shells are
-use for switching and creating databases
-show dbs
-shwo collections
-show users
-show profile
-show logs etc

Creating new documents in mongodb
we crate documents in mongodb using the inster command like the insertOne for inserting only one document and the insertMany for inserting more than one documents using an array.

Querying the DataBase
To find a document in the db use the find() method on the collection then pass a keyvalue filter that matches the data you want to filter. if we want to filter documetns using a number value we can us mongodb special varrible $lte which stands for less than or equal to e.g. db.find({price: {$lte: 500}}); this will now return all the documents have their price less than 500. To find the one greater than or equal to use the $gte e.g db.collection.find({rating: {$gte: number}}); this returns all documents having the rating price thats equl or greater than the number entered. This method of checking two conditions is like the and operator in javascript. we can check for one condition to one condition only using the $or operator e.g. db.collection.find({$or: [{price: {$lt: number}}, {rating: {$gte: number}}]});

Updating documents
Just like create documents we have the updateOne() which updates only one document and the updateMany() which updates more than one documents. 
e.g. updateOne:- db.collection.updateOne({filter}, {$set: {what to update in keyvalue pair}});

e.g. updateMany:- db.collection.updateMany({filter})

Note: you can aswell replace a document in your collection using the replaceOne and replaceMany using the same procedure as in updating.

Deleting document
Just like every other crud operator you can deleteOne or deleteMany documetns. e.g. db.collection.deleteOne(filter); db.collection.deleteMany(filter); to your whole collection use deleteMany({});

////////////////////////////////////////
//Mongoose
Mongoose is an object data modeling (ODM) libary for Mongodb and nodejs. Mongoose is like express in Nodejs i.e its the higher level of abstraction of interacting with mongodb. Mongoose allows for rapid and simple development of mongoDB database interaction i.e it connects our ide to the database. With mongoose we can use schema to model data and relationships, easy data validation, provides simple query API, middleware etc.

Mongoose schema:- This is a feature provided by mongoose to model our data by describing the structure of the data, setting defualt values, and validations.

Mongoose model:- Its like a wrapper for schema, providing an Interface to the database for CRUD operations.

mongoose is all about model and a model is like a blueprint for creating a docuemnt in our mongodb database.

////////////////////////////////////////////////
//BACKEND ARCHITECTURE 
#MVC: Modle view controller
This contains three layers which are the model layer, the controller layer, and the view lay.

The model layer takes care of the business logic.

The work of controller layer is to handle application logic which is handling request, interact with model and send back responses to the client.

The view layer takes care of the graphical interface i.e when dealing with server side rendered website. This is where the website template is being stored like .pug file.

Applicaiton logic vs Business logic
Application: These are code that is only concerned about the application's implementations like managing request and responses. It serves a bride btw model and view layer so they don't overlap.

Business logic: They are code that actully deals or solves business problem we set out to solve or any code related to that e.g created a new resources in our database like users etc, checking if user password is correct, validating user input data, ensuring only users who bought a resource can review it. 

//////////////////////////////////////////////////
//Mongodb Aggregation pipeline
This is mongodb framework for data aggregation i.e defining a pipeline where all the documents from a certain collection go through to be proccessed step by step in order to get aggregated result.

///////////////////////////////////////////////
//Mongoose middleware
#Four types of middleware in mongoose are
Document, Aggregate, Model and Query middleware.
1) Docuemnt middleware 
This is usually running a function btw the save command when the document is saved in the database i.e middleware that can act on currently processed document. 
This middleware is defined on the schema because the schema is like a blueprint for our document e.g. nameSchema.pre('save', function(next){});
with the .pre() method and passing the save argument the middleware runs before save and create. 

The .post() middleware function is executed after all .pre() middleware function is executed. This MidleWare also gets access to the created document e.g. nameSchema.post('save', function(document, next){})

NOte: just like express middleware the document middleware gets access to the next() function. 

This mongoose middlewares only runs for .save() and .create() methods and does not work for any kind of update like .updateMany() or .updateOne()

2)
The Query middleware
This middleware hook runs before or after a query is executed. It uses the same function as document middleware but the only differnce is in the event name which in this case is find and not save.

3)
The Aggregation middleware
This middleware allow us to add hooks before and after aggregation happens

///////////////////////////////
//Error handling
With express we can handle error from any where in our app by creating a global error handling middleware e.g. 
app.use(err, req, res, next){
  err.statusCode = err.statusCode || 500;
  err.status = err.status || 'error';
  res.status(err.statusCode).json({
    status: err.status,
    message: err.message,
  });
}
whenever we pass in four arguments in the use method express automatically detect the middleware as an error handling middleware. To make our errors avaliable to the error handling middleware use the next() method and pass in the err object which will shorcircuit all other middlewares and move directly to the error handling middleware.

///////////////////////////////////////
//Securing user password
NB: never leave a user password as plain text in the database.
instead we encrypt it e.g. this.password = await bcrypt.hash(this.password, 12);

encrypting the password is usually done in the pre hook middle before password is actully saved to the database.


//////////////////////////////////////////////
//How JWT works with Authentication
json web token is a stateless solution for authentication.
when a user is logged in the server checks if the user exists and if password is correct then it creates a unique JWT for the user which is sent back to the user. This JWT is like a passport that the user uses to access private datas like changing password or editing user profile by send the JWT along with a request like stated above. When this request hits the server it verifies if its valid i.e if the user is how it clams to be if the JWT is valid then the data requested for is sent back to the user and stored as a cookie or localstorage else access will be denied. This whole process is more secured under the https protocol which is the protected protocol for sending and recieving data btw the client and the server.

How JWT works 
JWT is made of three parts the header, the payload, and the signature.
The header is a metadata about the token itself i.e JWT

The payload is the data we encode into the token i.e the data we are transfering. The size of the payload is proportional to the size fo the JWT. The header and the payload are not encrypted.

The signature is where the magic happens. The signature is created using the header, the payload and the secret created at the server. The signature will process the signing of the JWT using the those info avaliable in the signature. 

During the signing process the header, payload and the secret are used to create a unique signature together with the header and payload form JWT which is sent to the client. Once the client gets the JWT it will verify it to check if the user is valid i.e checking if no one modified the payload and the header of the JWT. One the JWT reaches the verification process the header and the payload are used to create a test signature which is used to compire the original signature to test if the header and the payload are not modified i.e being change and if the test signature is equal the to the original signature then access will be granted else there won't be access. This whole process is made possible with the help of the secret section of the JWT which can't be tempered with because it's encrypted. 
NB: without the secret one will be able to manupulate the JWT data, 

////////////////////////////////////////
//Authorization
Which is verifying if a certain user has the right to access or interact with certain resource. And this is acheived with middleware i.e writing a middleware function that will check the role of the currentuser.

////////////////////////////////////////
//Password Reset 
email to forget passowrd route => returns mail + link => password reset page.

////////////////////////////////////////
//Security Best practice
Attacks that are likely to happen are
1) Compropmised DataBase where an attacker gains access to your database. To prevent this always Strongly encrypt password with salt and hash (e.g bcrypt) and Strongly encrypt password reset token(sha 256) aswell.
2) Brute Force Attacks:- This is a situation where an attacker trys millions of login password. to prevent use bcrypt to make login slow requests, implement rate limiting i.e how many requests that comes in certain ammount of time and implement maxium login attempts aswell.
3) Cross-site-scripting (xss) Attacks:- This is a situation where the attacker injects a mallisious script into our site to gain access expecially in the case of the local storage which in why we should never store jwt in localstorage.
preventions: Store JWT in Httpsonly cookies, sanitize user input data and set special http header(e.g helmet package)
4)DOS(Denial of service) Attacks:- A situation where the attacker makes so many request that the server crashes and the webapp is longer avaliable.
preventions: implement rate limiting(express-rate-limit), limit body payload and avoid evil reg expression.
4) NOSQL Query Injection:- A situation where attacker injects some query that might be true. 
preventions: Use mongoose for mongoDB(because of schematypes), sanitize user input data
5) Always use https
6) Create random password reset tokens with expiry database
7) Deny access to JWT after password change
8) Don't commit sensitive config data to git
9) Don't send error details to the client
10) Prevent *Cross site request Forgery* (csurf package)
11) Require re-auth before a high-value action
12) Implement a blacklist of unthrust JWT
13) Confirm user email address after first creating account 
14) Keep user logged in with refresh token (the user will be logged in forever).
15) Implement two-factor auth
16) Prevent parameter pollution (causes error if our applicaition is not prepared for it).

////////////////////////////////////////////
//Cookies 
This is small piece of text that a server can send to client. This client automatically stores the cookies that it recieved and automatically sends it back in all future request to the same server.  

//////////////////////////////////////////
//Data Modelling
This is the proccess of taking unstructured data generated by a real world scenario and structure them into logical data model in a database.

Data Modelling partern

1) Different types of relationships btw data
2) Referencing/normaliztion vs Embedding/denormalization
3) Embedding or refernceing other documents 
4) types of refernceing 

Types of Data relationships 
1) one to one:- this when one field can only have one value.

2) one to many:- Under one to many its futher divided into 1:few (e.g awards), 1:many(e.g reviews) and 1:ton(e.g app logs)
3) many to many

Referencing vs Embedded data modelling
In refernceing, documents are nicely seperated and are being referenced by there id i.e the parent will reference the child by their id. This is how datas are being stored in relational database i.e they are in normalized or referenced type.
pro and cons
increases performance when where querying for each decuments on its own.
cons
when we want fetch related data we'll have to do it based on the number of related documents the document we're querying is having.

Embedded or Denomalized 
Which is mostly used in NOSQL db datas are being Denomalized which is having all the related document inside one document and with this we'll only need to make few query which in turn increases performance but the downside is that we cant query only the embedded datas on its own because its embedded inside a big document which we'll have to query in order to gain access to the embedded object 

How to normalize or denormalize data
1) Check the Relationship Type i.e how two datasets are related to each other.
when we have a 1:few data use embedded format of modelling data.
case 1:many use either embedded or refernceing depending on the read/write ratio i.e if the data is read often then Referencing else if its written a lot then use embedded format and the benefit is that by embedding we only do one trip to the database saving us time while in refernceing we do two trip. Again refernceing is for datas that have a low read/write ratio while that of embedded is for datas that are having high read/write ratio.
case 1:ton and Many:Many use refernceing.
--------------------------------------------------
2) Check the data access parttern i.e how often data is read and written. 
use embedded for datas with high read/write ratio then datas with low read/write ratio use refernceing.

--------------------------------------------------
3) Data Closeness i.e how much the data is related.
 
--------------------------------------------------

Types of refernceing
Child refernceing, Parent refernceing and two-way refernceing
Child refernceing happens when we query a document and it refenrces other docuemnt. Using child referenceing is not optimal cos the parentg document size grow as the number of child increases and this might lead to breaking the limiting of each document which is 60mb. Best used for one to few relationships.

Parent refernceing if the opposite of child refernceing. Its best to use parent Referencing cos the child only has the id of the parent. best for 1:many and 1:ton relationships. 

TIPS: 
# The most important principle is to structure your data to match the ways that your applicaition queries and updates data.
# Always favour embedding, unless there is a reason not embed. especially on 1:few and 1:many relationships.
# A 1:ton and many:many relationships is usually a good reason to refernce instead of embedding.
# Favour Referencing when data is updated a lot and if you need to frequently access a dataset on its own.
# Use embedding when data is mostly read but rarely updated and when to datasets belong intrinsically together.
# Don't allow arrays to grow indefinitely in your document. Therfore, if you need to normalize use child referencing for 1:many relationships and parent refernceing for 1:ton Relationships.
# use two-way referencing for many:many relationships.

///////////////////////////////////////////////////
//Geospatial location
Mongodb supports geospatial data which is datas that discribes or identify  places on earth using logitude and latitude.

IMPROVING READ PERFORMANCE WITH INDEXES
Reading document from a big database can be time consuming so indexing is the best to improve performance in reading data. with indexing all the indexed resources id are stored inside the index created. This makes the read performance better.